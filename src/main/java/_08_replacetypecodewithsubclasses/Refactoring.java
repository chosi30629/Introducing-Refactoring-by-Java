package _08_replacetypecodewithsubclasses;


/**
 * 이름 : 분류 코드를 하위 클래스로 치환
 *
 * 상황 : 분류 코드마다 객체가 다른 동작을 함
 *
 * 문제 : switch 문을 써서 동작을 구분함
 *
 * 해법 : 분류 코드를 하위 클래스로 치환해서 다향적 메서드를 작성함
 *
 * 결과 : 동작이 클래스별로 나뉨
 *       클래스 개수가 늘어남
 *
 * 방법 : (1) 분류 코드에 대응하는 하위 클래스 작성
 *          1) 분류 코드를 자기 캡슐화
 *              - 분류 코드를 나타내는 필드를 직접 보여주는 게 아니라 게터 메서드를 통해 보여주기
 *              - 자기 캡슐화 필드
 *          2) 분류 코드를 바탕으로 인스턴스를 작성하고 있다면 팩토리 메서드 작성
 *              - 생성자를 팩토리 메서드로 치환
 *          3) 분류 코드 값마다 하위 클래스 작성
 *              - 하위 클래스에서 분류 코드 게터 메서드를 오버라이드
 *              - switch 문에 적힌 동작을 하위 클래스로 이동
 *              - 메서드 내리기
 *          4) 컴파일해서 테스트
 *       (2) 불필요한 필드 삭제
 *          1) 분류 코드 필드 삭제
 *          2) 기존 클래스의 분류 코드 게터 메서드를 추상 메서드로 만듦
 *          3) 컴파일해서 테스트
 *
 * 관련항목 : (1) 분류 코드를 클래스로 치환(7장)
 *              - 동작이 규정되어 있지 않을 때 사용
 *          (2) 자기 캡슐화 필드
 *              - 분류 코드를 나타내는 필드용으로 게터 메서드 작성
 *          (3) 메서드 내리기
 *              - 게터 메서드를 하위 클래스로 이동할 때나 switch 문에 적힌 동작을 하위 클래스로 이동할 때 사용
 *          (4) 생성자를 팩토리 메서드로 치환(11장)
 *              - 분류 코드를 기반으로 객체를 작성할 때 사용
 *
 * 팩토리 메서드는 인스턴스를 작성하기 위한 메서드이다.
 *  - 인스턴스를 만들 뿐이라면 new 연산자를 사용하면 되겠지만, 그런 경우 클래스명을 직접 작성해야 한다.
 *  - 팩토리 메서드는 만들 인스턴스 클래스명을 은폐하려고 사용한다.
 *
 * 상위 클래스 쪽에서 구현하지 않는 메서드를 추상 메서드로 만드는 건 좋은 방법이다.
 *  - 추상 메서드로 지정하면 '이건 하위 클래스에서 구현해야 하는 메서드'라는 게 명확해지기 때문이다.
 *  - 예제에서 다각형을 나타내는 ShapePolygon 이라는 하위 클래스를 새로 만든다면 ShapePolygon 에서 구현해야하는 건
 *    getTypecode, getName, draw 세 메서드임을 바로 알 수 있다.
 *
 * 어디까지 리팩토링 해야하나?
 *  - 상황에 따라 다르다.
 *  - 예제 프로그램 정도의 소규모라면 소스 코드 전체를 파악하기가 어렵지 않아 이런 경우는 무리해서 switch 문을 제거하지 않는 쪽이 알기 쉽다.
 *  - 하지만 프로글매이 점점 커져서 전체를 파악하지 어려워지면 빨리 리팩토링하는 게 좋다.
 *  - 리팩토링을 해야 하는지 여부는 기능 추가 예쩡이 있는지도 중요하다.
 *  - 기능이 추가 될 수록 switch 문의 case 도 많아지기 때문이다.
 *  - 리팩토링 관련해서 절대적인 정답은 없다.
 *  - 실제 소프트웨어 개발에서는 무리해서라도 이런 리팩토링은 꼭 해야 한다고 단정하는 게 아니라 상황에 따라 적절히 판단하는 게 중요하다.
 *  - '이건 좀 별로인가?' 하는 생각이 들면 리팩토링을 원래대로 되돌리는 것도 중요하다.
 *
 */
public class Refactoring {
}
