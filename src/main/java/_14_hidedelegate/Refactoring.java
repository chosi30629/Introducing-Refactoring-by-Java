package _14_hidedelegate;


/**
 * 이름 : 대리자 은폐
 *
 * 상황 : 클래스에 위임 관계가 있음
 *
 * 문제 : 클라이언트 클래스가 서버 클래스뿐만 아니라 대리 클래스까지 이용함
 *
 * 해법 : 서버 클래스에 위임 메서드를 추가해서 클라이언트 클래스로부터 대리 클래스를 은폐
 *
 * 결과 : 클래스 사이의 불필요한 관계가 줄고 코드 수정이 쉬워짐
 *       서버 클래스의 책임이 늘어남
 *
 * 방법 : (1) 위임 메서드 작성
 *          1) 대리 클래스의 메서드에 대응하는 위임 메서드를 서버 클래스에 작성
 *          2) 클라이언트 클래스는 대리 클래스가 아닌 서버 클래스를 호출하도록 변경
 *          3) 컴파일해서 테스트
 *       (2) 대리 클래스 은폐
 *          1) 서버 클래스에 있는 대리 클래스의 게터 메서드 삭제
 *          2) 컴파일해서 테스트
 *
 * 관련 항목 : 중개자 제거
 *              - 대리자 은폐 결과 서버 클래스의 메서드가 모두 위임 메서드가 되었다면 서버 클래스를 삭제 가능
 *           클래스 인라인화
 *              - 대리 클래스가 별다른 일을 하지 않는다면 대리 클래스는 서버 클래스에 인라인화 가능
 *
 * 정보 은폐(information hiding)는 '상세 구현을 숨기는 것'을 뜻한다. 소프트웨어 개발에서 적절한 정보 은폐는 중요하다.
 *  - 상세 구현을 숨기지 않으면 클래스끼리 의존 관계가 너무 깊어질 위험이 있다.
 *  - 서버 클래스의 상세 구현을 숨기면 그런 상세 구현에 의존하는 클라이언트 클래스는 없어진다.
 *    그러먼 클래스 수정이 무척 편해진다. 수정에 따른 영향 범위가 줄어들기 때문이다.
 *
 * 중개자 제거
 *  - 대리자 은폐가 유용한 상황은 대리자 은폐로 클래스 사이의 관계가 간결해질 때이다. 대리자 은폐를 하면 분명히 클라이언트 클래스와
 *    대리 클래스의 관계는 끊지기만 서버 클래스 안에 위임 메서드가 늘고 책임이 늘어나는 단점이 있다.
 *  - 예를 들어 모든 메서드가 위임 메서드인 클래스가 있다고 하면 그 클래스 메서드는 다른 클래스의 메서드를 호출할 뿐이다.
 *    그런 클래스는 '클래스와 클래스 사이를 중개하는 역할', 즉 중개자라고 부른다. 중개자는 이쪽에서 말하는 걸 조쪽에 전달하는 일밖에
 *    하지 않는다. 그런 중개자를 삭제하는 것도 클래스 사이의 관계를 정리하는 일이다. 이것이 중개자 제거(Remove Middle Man)이다.
 *  - 대리자 은폐를 하면 좋을지, 중개자 제거를 하면 좋을지는 그때그때 다르다. 프로그램 규모, 클래스 책임 분담 정도, 추후 수정 예정 등을
 *    생각해서 클래스 사이의 관계를 파악하자. '이 클래스는 위임할 클래스를 호출하고 있으니 대리자 은폐를 하면 좋겠지?'하고 생각해 보거나,
 *    '이 클래스는 위임 메서드뿐이니까 중개자 제거를 검토해 보자'처럼 생각해 보는 태도 둘 다 중요하다.
 *
 * 클래스 인라인화
 *  - 대리자 은폐 결과로 대리 클래스가 별다른 처리를 안 한다는걸 알았다고 하자. 그러면 대리 클래스를 단독 클래스로 만들기보단 서버 클래스 안에
 *    인라인화해서 집어넣어야 클래스 관계가 간단해진다. 그렇게 별 거 없는 클래스 내용이라면 이용하는 크랠스 안에 집어넣는 리팩토링이
 *    클래스 인라인화(Inline Class)이다.
 *  - 제대로 클래스 인라인화하면 클래스 개수가 줄어든다.
 */
public class Refactoring {
}
