package _09_replacetypecodewithstatestrategy;


/**
 * 이름 : 분류 코드를 상태/전략 패턴으로 치환
 *
 * 상황 : 분류 코드마다 객체가 다른 동작을 함
 *
 * 문제 : 동작을 switch 문으로 나누고 있지만 분류 코드가 동적으로 변하므로 분류 코드를 하위 클래스로 치환은 사용 불가
 *
 * 해법 : 분류 코드를 나타내는 새로운 클래스를 작성해서 상태/전략 패턴을 사용함
 *
 * 결과 : 분류 코드 타입 판별이 가능해짐
 *       분류 코드에 따른 클래스 동작을 다형성으로 해결 가능
 *       클래스 개수가 늘어남
 *
 * 방법 : (1) 상태 객체를 나타내는 클래스 작성
 *          1) 분류 코드를 자기 캡슐화
 *          2) 분류 코드를 나타내는 새로운 클래스(상태 클래스) 작성
 *          3) 분류 코드 값마다 상태 객체의 하위 클래스 작성
 *          4) 분류 코드를 얻는 추상 메서드를 상태 객체에 작성
 *          5) 하위 클래스는 추상 메서드를 오버라이드해서 분류 코드를 반환
 *          6) 컴파일
 *       (2) 상태 객체 사용
 *          1) 분류 코드를 사용하는 클래스에 상태 객체용 필드 추가
 *          2) 분류 코드를 조사하는 코드를 분류 코드를 얻는 메서드 호출로 치환
 *          3) 분류 코드를 변경하는 코드를 상태 객체를 변경하는 코드로 치환
 *          4) 컴파일해서 테스트
 *
 * 관련 항목 : (1) 자기 캡슐화 필드
 *           (2) 분류 코드를 클래스로 치환(7장)
 *           (3) 분류 코드를 하위 클래스로 치환(8장)
 *
 * 자기 캡슐화 : 클래스 내부에서 분류 코드 필드에 대한 접근이 있어도 반드시 접근자(게터 메서드, 세터 메서드)를 경유하게 만드는 수정
 *  - 접근자만 변경하면 필드를 다루는 방법을 바꿀 수 있어서 편리
 *  - 일반 적으로 필드에 접근할 때 접근자를 경유하도록 하는 리팩토링을 필드 캡휼화라고 부르지만, 자기 캡슐화는 한 걸음 더 나아가 자기 클래스
 *    내부의 접근도 접근자를 경유한다. 이러한 리팩토링을 자기 캡슐화 필드라고 한다.
 *
 * 상태 패턴은 프로그램 상태를 객체로 표현하고 상태를 의존하는 코드를 하위 클래스 메서드에 작성하는 것이다.
 *  - 이것으로 상태에 따른 switch 문이 없어져서 상태 전이도 깔끔하게 작성할 수 있다.
 *
 * 전략 패턴은 하나로 정리된 처리를 하는 알고리즘을 조용히 전환할 때 사용하는 패턴이다.
 *  - 알고리즘 입출력을 인터페이스로 규정해 두고 그 인터페이스를 만족하는 구체적인 클래스를 선언한다. 이렇게 하면 요구에 따른 알고리즘을
 *    선택(예를 들면 속도 우선, 적은 메모리 소비량 우선 등)할 수 있어서 한 알고리즘을 다른 알고리즘으로 바꿔서 재계산하는 일이 편해진다.
 *
 * 상태 패턴과 전략 패턴은 프로그램을 클래스 다이어그램으로 나타내면 구별이 되지 않는다.
 *  - 두 패턴은 목적이 다를 뿐 정적 구조는 같다.
 *  - 리팩토링 절차도 상태 패턴과 전략 패턴에 차이가 없다.
 */
public class Refactoring {
}
